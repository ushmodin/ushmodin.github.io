---
layout: post
title: Мысли о C10K
tags:
  - hightload
  - C10K
main-class: C10K
introduction: 'Немного мыслей о - проблеме C10K'
draft: true
---

**Друзья, всем привет!**

Если обратиться к (wiki)[https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_10000_%D1%81%D0%BE%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9] то проблема C10K - это задача конфигурирования сервера способного обслуживать 10000 подключений одновременно.
Странно почему это проблема ведь это здорово, что на наш сервер пришло такое количество запросов.
И заметьте, пришли не в течении секунды или минуты а одновременно.
Хотя сложно представить, что значит "одновременно" для процессора, который работает по тактам.
Предположим под "одновременно" будем иметь в виду малый промежуток времени стремящийся к нулю.

Далее в статье говорится что аппаратное обеспечение справляется с такой задачей, но проблема может возникнуть в программном алгоритме.

Первый вариант алгоритма - (thread per request) обработка запроса происходит в рамках выделенного потока.
Метод прост и удобен потому, что при программировании стоит задача ответить на один запрос.
Обычно все сложности синхронизации одновременных запросов решают внешние системы такие как базы данных или очереди.
Когда необходимо работать с ресурсом, который не способен работать в конкурентном режиме, о синхронизации приходится заботиться самостоятельно.
Не смотря на использование потоков процессор выполняет все команды последовательно, и количество потоков которые действительно будут работать одновременно зависит от количества ядер в процессоре.
С увеличением количества потоков общая производительность системы может уменьшается из за накладных расходов на содержание потоков.


```java
class Request {
    private final InputStream inputStream;
    private final OutputStream outputStream;

    public Request(byte[] bytes) {
        inputStream = new ByteArrayInputStream(bytes);
        outputStream = new ByteArrayOutputStream();
    }

    public InputStream getInputStream() {
        return inputStream;
    }

    public OutputStream getOutputStream() {
        return outputStream;
    }
}
```

```java
class BusinessLogic {
    public void echo(Request request) throws IOException, InterruptedException {
        IOUtils.copy(request.getInputStream(), request.getOutputStream());
    }
}
```

```java
        Request [] requests = new Request[THREADS];
        for (int i = 0; i < THREADS; i++) {
            byte[] randomData = RandomStringUtils.random(100).getBytes();
            requests[i] = new Request(randomData);
        }
        BusinessLogic bl = new BusinessLogic();
```

```java
        List<Callable<Void>> callables = new ArrayList<>();
        for (Request request : requests) {
            callables.add(() -> {
                bl.echo(request);
                return null;
            });
        }

        ExecutorService threadPool = Executors.newFixedThreadPool(THREADS);
        long start = System.currentTimeMillis();
        threadPool.invokeAll(callables);
        long end = System.currentTimeMillis();
        threadPool.shutdown();
        System.out.println(end - start);
```

```java
        long start = System.currentTimeMillis();
        for (Request request : requests) {
            bl.echo(request);
        }
        long end = System.currentTimeMillis();
        System.out.println(end - start);
```
